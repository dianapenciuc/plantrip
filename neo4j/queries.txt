LOAD CSV WITH HEADERS FROM 'file:///graph-reg-idf.csv' AS row
    CREATE (:POI {
        name: row.Nom_du_POI,
        id: row.URI_ID_du_POI,
        city: row.Commune,
        category: row.Categories_de_POI,
        coordinates:[toFloat(row.Latitude),toFloat(row.Longitude)]
        });
LOAD CSV WITH HEADERS FROM 'file:///cities_clean.csv' AS row
    CREATE (:City {
        name: row.label,
        cityCode: row.city_code,
        id: row.insee_code,
        zipCode: row.zip_code,
        regionName: row.region_name,
        departementId: row.department_number,
        departementName: row.department_name,
        coordinates:[toFloat(row.latitude),toFloat(row.longitude)]
        });

match(c:City) return distinct c.regionName

match(c:City{name:"paris"}) return c

match(n:POI{city:'paris'}) where n.category CONTAINS 'placeofinterest'  return n

#créer une projection pour les POIs de type placeofinterest à Paris
match(n:POI{city:'paris'}) where n.category CONTAINS 'placeofinterest'  
WITH gds.graph.project(
'pois_paris',n
) as g
return g.graphName AS graph, g.nodeCount AS nodes, g.relationshipCount AS rels

#delete graph
CALL gds.graph.drop('pois_paris') YIELD graphName;

CALL gds.graph.project(
'pois',
{
  POI: {
    properties: 'coordinates'
  }
},
'*'
);

#estime la quantité de mémoire nécessaire au clustering
CALL gds.kmeans.write.estimate('pois', {
  writeProperty: 'kmeans',
  nodeProperty: 'coordinates'
})
YIELD nodeCount, bytesMin, bytesMax, requiredMemory

#vérifie la distribution des clusters
CALL gds.kmeans.stats('pois', {
  nodeProperty: 'coordinates',
  k: 10,
  randomSeed: 42
})
YIELD communityDistribution

#je donne les coordonnées de plusieurs villes importantes : Paris, Versailles, Coupvray
#et je construits les clusters autour de ces points
CALL gds.kmeans.stream('cities', {
  nodeProperty: 'coordinates',
  k: 3,
  seedCentroids: [[48.86287791,2.3599986], [48.802292474,2.117410101],[48.885771198,2.793406447]]
})
YIELD nodeId, communityId
RETURN gds.util.asNode(nodeId).name AS name, communityId
ORDER BY communityId, name ASC

#je sélectionne les POIs de type 'placeofinterest' dans le cluster autour de Paris
CALL{
CALL gds.kmeans.stream('poisparis', {
  nodeProperty: 'coordinates',
  k: 3,
  seedCentroids: [[48.86287791,2.3599986], [48.802292474,2.117410101],[48.885771198,2.793406447]]
})
YIELD nodeId, communityId
RETURN gds.util.asNode(nodeId) AS node, communityId
ORDER BY communityId
} with node,communityId where communityId = 0 AND node.category CONTAINS 'placeofinterest' return node

#je cherche de POIs à Paris, sauf hébergements, services 
CALL{
CALL gds.kmeans.stream('poisparis', {
  nodeProperty: 'coordinates',
  k: 3,
  seedCentroids: [[48.86287791,2.3599986], [48.802292474,2.117410101],[48.885771198,2.793406447]]
})
YIELD nodeId, communityId
RETURN gds.util.asNode(nodeId) AS node, communityId
ORDER BY communityId
} with node,communityId where communityId = 0 AND (node.city = 'paris') AND (node.category CONTAINS 'placeofinterest') AND (NOT (node.category CONTAINS 'accommodation')) AND (NOT (node.category CONTAINS 'serviceprovider')) return node

#je cherche de POIs à Paris, sauf hébergements, services 
CALL{
CALL gds.kmeans.stream('poisparis', {
  nodeProperty: 'coordinates',
  k: 3,
  seedCentroids: [[48.86287791,2.3599986], [48.802292474,2.117410101],[48.885771198,2.793406447]]
})
YIELD nodeId, communityId
RETURN gds.util.asNode(nodeId) AS node, communityId
ORDER BY communityId
} with node,communityId where communityId = 0 AND (node.city = 'paris') AND (node.category NOT (CONTAINS ['serviceprovider','accommodation'])) return node

# recherche les POIs dans un bounding box autour d'un point de départ, par exemple (48.85,2.25)
WITH
  point({longitude: 2.25 - 0.015, latitude:48.85 - 0.015 }) AS lowerLeft,
  point({longitude: 2.25 + 0.015, latitude: 48.85 + 0.015}) AS upperRight
MATCH (p:POI)
WHERE point.withinBBox(point({longitude: p.coordinates[1], latitude: p.coordinates[0]}), lowerLeft, upperRight)
AND NOT (p.category CONTAINS 'accomodation') and not (p.category CONTAINS 'restaurant')
RETURN p

#recherche dans un rectangle autour d'un POI avec sélection des catégories
WITH
  point({longitude: 2.35185 - 0.02, latitude:48.85955 - 0.02 }) AS lowerLeft,
  point({longitude: 2.25 + 0.02, latitude: 48.85 + 0.02}) AS upperRight
MATCH (p:POI{city:'paris'})
where point.withinBBox(point({longitude: p.coordinates[1], latitude: p.coordinates[0]}), lowerLeft, upperRight)
and all(x in split(p.category,' ') WHERE NOT(x in ['serviceprovider','foodestablishment','accommodation','restaurant','transport','sportsandleisureplace','medicalplace','store']))
and p.category <> "placeofinterest pointofinterest"
RETURN p order by p.coordinates[0] asc limit 20

#recherche du poi le plus proche autour d'un point, à une distance < 1km
WITH
  point({longitude: 2.35185 - 0.017, latitude:48.85955 - 0.017 }) AS start_point
MATCH (p:POI{city:'paris'})
WITH start_point,p, point.distance(start_point,point({longitude:p.coordinates[1],latitude:p.coordinates[0]})) as distance
where any(x in split(p.category,' ') where x in ['service','culturalsite']) and distance < 1000
RETURN p order by distance asc limit 1

WITH
  point({longitude: 2.35185 - 0.017, latitude:48.85955 - 0.017 }) AS start_point
MATCH (p:POI{city:'paris'})
WITH start_point,p, point.distance(start_point,point({longitude:p.coordinates[1],latitude:p.coordinates[0]})) as distance
where any(x in split(p.category,' ') where x in ['service','culturalsite']) and distance < 1000
RETURN p.id,distance order by distance asc limit 20

#Teste avec un graph non-orienté
CALL gds.graph.project(
    'ParisOnfoot',
    'POI',{
    ONFOOT:
    {
        properties: 'duration', 
        orientation: 'UNDIRECTED'
    }
    }
)
#Je cherche les minimum spanning trees de taille 10 (je garde 10 POIs)
MATCH (source:POI {id: 'https://data.datatourisme.fr/19/8073f478-e038-3753-b4be-1710a9b7104d'})
CALL gds.kSpanningTree.write('ParisOnfoot', {
  k: 10,
  sourceNode: source,
  relationshipWeightProperty: 'duration',
  writeProperty:'kmin'
})
YIELD preProcessingMillis, computeMillis, writeMillis, effectiveNodeCount
RETURN preProcessingMillis,computeMillis,writeMillis, effectiveNodeCount;

#Je récupère les POIs du minimum spanning tree
MATCH (n)
WITH n.kmin AS p, count(n) AS c
WHERE c = 10
MATCH (n)
WHERE n.kmin = p
RETURN n.id, n.coordinates,n.name, p as Partition

