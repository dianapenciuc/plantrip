LOAD CSV WITH HEADERS FROM 'file:///graph-reg-idf.csv' AS row
    CREATE (:POI {
        name: row.Nom_du_POI,
        id: row.URI_ID_du_POI,
        city: row.Commune,
        category: row.Categories_de_POI,
        coordinates:[toFloat(row.Latitude),toFloat(row.Longitude)]
        });
LOAD CSV WITH HEADERS FROM 'file:///cities_clean.csv' AS row
    CREATE (:City {
        name: row.label,
        cityCode: row.city_code,
        id: row.insee_code,
        zipCode: row.zip_code,
        regionName: row.region_name,
        departementId: row.department_number,
        departementName: row.department_name,
        coordinates:[toFloat(row.latitude),toFloat(row.longitude)]
        });

match(c:City) return distinct c.regionName

match(c:City{name:"paris"}) return c

match(n:POI{city:'paris'}) where n.category CONTAINS 'placeofinterest'  return n

#créer une projection pour les POIs de type placeofinterest à Paris
match(n:POI{city:'paris'}) where n.category CONTAINS 'placeofinterest'  
WITH gds.graph.project(
'pois_paris',n
) as g
return g.graphName AS graph, g.nodeCount AS nodes, g.relationshipCount AS rels

#delete graph
CALL gds.graph.drop('pois_paris') YIELD graphName;

CALL gds.graph.project(
'pois',
{
  POI: {
    properties: 'coordinates'
  }
},
'*'
);

#estime la quantité de mémoire nécessaire au clustering
CALL gds.kmeans.write.estimate('pois', {
  writeProperty: 'kmeans',
  nodeProperty: 'coordinates'
})
YIELD nodeCount, bytesMin, bytesMax, requiredMemory

#vérifie la distribution des clusters
CALL gds.kmeans.stats('pois', {
  nodeProperty: 'coordinates',
  k: 10,
  randomSeed: 42
})
YIELD communityDistribution

#je donne les coordonnées de plusieurs villes importantes : Paris, Versailles, Coupvray
#et je construits les clusters autour de ces points
CALL gds.kmeans.stream('cities', {
  nodeProperty: 'coordinates',
  k: 3,
  seedCentroids: [[48.86287791,2.3599986], [48.802292474,2.117410101],[48.885771198,2.793406447]]
})
YIELD nodeId, communityId
RETURN gds.util.asNode(nodeId).name AS name, communityId
ORDER BY communityId, name ASC

#je sélectionne les POIs de type 'placeofinterest' dans le cluster autour de Paris
CALL{
CALL gds.kmeans.stream('poisparis', {
  nodeProperty: 'coordinates',
  k: 3,
  seedCentroids: [[48.86287791,2.3599986], [48.802292474,2.117410101],[48.885771198,2.793406447]]
})
YIELD nodeId, communityId
RETURN gds.util.asNode(nodeId) AS node, communityId
ORDER BY communityId
} with node,communityId where communityId = 0 AND node.category CONTAINS 'placeofinterest' return node

#je cherche de POIs à Paris, sauf hébergements, services 
CALL{
CALL gds.kmeans.stream('poisparis', {
  nodeProperty: 'coordinates',
  k: 3,
  seedCentroids: [[48.86287791,2.3599986], [48.802292474,2.117410101],[48.885771198,2.793406447]]
})
YIELD nodeId, communityId
RETURN gds.util.asNode(nodeId) AS node, communityId
ORDER BY communityId
} with node,communityId where communityId = 0 AND (node.city = 'paris') AND (node.category CONTAINS 'placeofinterest') AND (NOT (node.category CONTAINS 'accommodation')) AND (NOT (node.category CONTAINS 'serviceprovider')) return node
